#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const glob = require('glob');
const mustache = require('mustache');
const mkdirp = require('mkdirp');
const {
    compose,
    not,
    test: testRegex,
} = require('ramda');

const {
    InvalidModuleConfigError,
} = require('../utils/exceptions');

const {
    log,
    parseArgs,
    getConfig,
    isDirectory,
    isFile,
    getTemplatePath,
    importModule,
    joinPathWith,
} = require('../utils/helpers');


const PROJECT_ROOT = path.resolve(__dirname, '../');
const USER_DIR = path.resolve();

const boilerplateName = getConfig('boilerplateName');

const templatePath = getTemplatePath(boilerplateName);

if(!templatePath) {
    throw new InvalidModuleConfigError('Invalid boilerplate directory');
}

const boilerplateModule = importModule(templatePath);

if(typeof boilerplateModule !== 'function') {
    throw new InvalidModuleConfigError('Template module needs to export a function');
}

// TODO: Check if boilerplateModule is a function
const templateConfig = boilerplateModule({ args: getConfig('args') });

const {
    ignore: ignoredRegex,
    data: templateData,
    preventExecution = false
} = templateConfig;

if(preventExecution) {
    return;
}

const templateDirGlob = './**/*';

const boilerplateFiles =
    glob.sync(path.join(templatePath, 'template', templateDirGlob));

boilerplateFiles
    .filter(isFile)
    .filter(compose(not, testRegex(ignoredRegex)))
    .map(filePath => {

        let fileContents = fs.readFileSync(filePath);
        fileContents =
            mustache.render(fileContents.toString(), templateData);

        let outDir = path.join(USER_DIR, getConfig('outDir'));
        outDir = filePath.replace(path.join(templatePath, 'template'), outDir);

        mkdirp.sync(path.dirname(outDir));

        fs.writeFileSync(outDir, fileContents);
    });

