#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const glob = require('glob');
const yargs = require('yargs');
const mustache = require('mustache');
const mkdirp = require('mkdirp');
const {
    compose,
    not,
    test: testRegex,
} = require('ramda');

const PROJECT_ROOT = path.resolve(__dirname, '../');
const USER_DIR = path.resolve();

/*

type Args = {
    boilerplateName :: String
    outDir :: String
    args :: Object<String>
}

type TemplateConfig = {
    templateDirGlob :: String
    data :: Object
}

*/

const log = name => data => {
    console.log(name, data);
    return data;
};

// parseArgs :: () -> Args
const parseArgs = () => {
    const { _: [ boilerplateName ], o: outDir, ...args } = yargs.argv;
    return { boilerplateName, outDir, args };
};

// getConfig :: String -> String
const getConfig = key => parseArgs()[key];

// isDirectory :: String -> Boolean
const isDirectory = dpath => {
    try {
        return fs.lstatSync(dpath).isDirectory();
    } catch(e) {
        return false;
    }
};
// isFile :: String -> Boolean
const isFile = fpath => {
    try {
        return fs.lstatSync(fpath).isFile();
    } catch(e) {
        return false;
    }
};

// getTemplatePath :: String -> Either<String>
const getTemplatePath = templateName => {

    let templatePath =
        path.join(PROJECT_ROOT, 'packages', templateName);

    return isDirectory(templatePath)? templatePath: '';
};

// importModule :: String -> Function
const importModule = require;

// joinPathWith :: String -> String -> String
const joinPathWith = p2 => p1 => path.join(p1, p2);



const boilerplateName = getConfig('boilerplateName');

const templatePath = getTemplatePath(boilerplateName);

if(!templatePath) {
    return;
}

const boilerplateModule = importModule(templatePath);

// TODO: Check if boilerplateModule is a function
const templateConfig = boilerplateModule({ args: getConfig('args') });

const {
    ignore: ignoredRegex,
    data: templateData,
    preventExecution = false
} = templateConfig;

if(preventExecution) {
    return;
}

const templateDirGlob = './**/*';

const boilerplateFiles =
    glob.sync(path.join(templatePath, 'template', templateDirGlob));

boilerplateFiles
    .filter(isFile)
    .filter(compose(not, testRegex(ignoredRegex)))
    .map(filePath => {

        let fileContents = fs.readFileSync(filePath);
        fileContents =
            mustache.render(fileContents.toString(), templateData);

        let outDir = path.join(USER_DIR, getConfig('outDir'));
        outDir = filePath.replace(path.join(templatePath, 'template'), outDir);

        mkdirp.sync(path.dirname(outDir));

        fs.writeFileSync(outDir, fileContents);
    });

